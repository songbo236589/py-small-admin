# 分表使用文档

## 概述

本项目的分表模块提供了通用的数据库分表功能，基于 SQLModel 模型实现，支持多种分表策略。该模块封装了表路由、表管理、数据查询和数据写入等核心功能，提供了简单易用的接口。

该模块主要包含以下文件：

- `Modules/common/libs/database/sharding/manager.py`: 分表管理器
- `Modules/common/libs/database/sharding/table_creator.py`: 分表创建器
- `Modules/common/libs/database/sharding/cache_utils.py`: 缓存工具类
- `Modules/common/libs/database/sharding/strategies/`: 分表策略实现
  - `base.py`: 分表策略抽象基类
  - `time_based.py`: 基于时间的分表策略
  - `id_based.py`: 基于 ID 的分表策略
  - `hash_based.py`: 基于哈希的分表策略

## 主要功能

- 支持多种分表策略（时间、ID、哈希）
- 自动表路由和表管理
- 支持单表查询和跨表查询
- 批量数据插入和更新
- 表存在性缓存（基于 Redis）
- 分布式锁避免重复创建表
- 自动时间戳管理（created_at、updated_at）
- 完整的错误处理和日志记录

## 安装与导入

```python
from Modules.common.libs.database.sharding import (
    # 管理器
    ShardingManager,
    ShardingTableCreator,
    
    # 分表策略
    ShardingStrategy,
    TimeBasedShardingStrategy,
    IdBasedShardingStrategy,
    HashBasedShardingStrategy,
    
    # 缓存工具
    ShardingCacheManager,
)
```

## 分表策略

### 1. 基于时间的分表策略

`TimeBasedShardingStrategy` 适用于时间序列数据，如日志、订单、交易记录等。

#### 支持的时间粒度

- `year`: 按年分表（如 `table_2024`）
- `month`: 按月分表（如 `table_202401`）
- `day`: 按日分表（如 `table_20240115`）

#### 使用示例

```python
from datetime import date
from Modules.common.libs.database.sharding import TimeBasedShardingStrategy

# 按年分表
strategy_year = TimeBasedShardingStrategy("trade_date", granularity="year")
table_name = strategy_year.get_table_name(date(2024, 1, 15), "quant_stock_klines_1d_")
print(table_name)  # quant_stock_klines_1d_2024

# 按月分表
strategy_month = TimeBasedShardingStrategy("trade_date", granularity="month")
table_name = strategy_month.get_table_name(date(2024, 1, 15), "quant_stock_klines_1d_")
print(table_name)  # quant_stock_klines_1d_202401

# 按日分表
strategy_day = TimeBasedShardingStrategy("trade_date", granularity="day")
table_name = strategy_day.get_table_name(date(2024, 1, 15), "quant_stock_klines_1d_")
print(table_name)  # quant_stock_klines_1d_20240115

# 获取时间范围涉及的表
table_names = strategy_year.get_table_names_by_range(
    date(2023, 6, 1),
    date(2024, 12, 31),
    "quant_stock_klines_1d_"
)
print(table_names)  # ['quant_stock_klines_1d_2023', 'quant_stock_klines_1d_2024']
```

#### 适用场景

- 日志数据按时间归档
- 交易记录按时间分表
- 订单数据按月/年分表
- 统计数据按时间维度分表

### 2. 基于 ID 的分表策略

`IdBasedShardingStrategy` 适用于用户数据、订单数据等，支持按范围或取模分表。

#### 分表方式

- `range`: 按范围分表（如 ID 0-999 在表 0，1000-1999 在表 1）
- `mod`: 按取模分表（如 ID % 10 = 0 在表 0，ID % 10 = 1 在表 1）

#### 使用示例

```python
from Modules.common.libs.database.sharding import IdBasedShardingStrategy

# 按取模分表
strategy_mod = IdBasedShardingStrategy("user_id", mode="mod", mod_value=10)
table_name = strategy_mod.get_table_name(123, "users_")
print(table_name)  # users_3

# 按范围分表（每1000条记录一个表）
strategy_range = IdBasedShardingStrategy("user_id", mode="range", range_size=1000)
table_name = strategy_range.get_table_name(12345, "users_")
print(table_name)  # users_12

# 获取 ID 范围涉及的表
table_names = strategy_mod.get_table_names_by_range(15, 35, "users_")
print(table_names)  # ['users_0', 'users_1', 'users_2', 'users_3', 'users_4', 'users_5']

table_names = strategy_range.get_table_names_by_range(1500, 3500, "users_")
print(table_names)  # ['users_1', 'users_2', 'users_3']
```

#### 适用场景

- 用户数据按 ID 分表
- 订单数据按 ID 分表
- 需要精确查询特定 ID 范围的数据
- 数据分布相对均匀的场景

### 3. 基于哈希的分表策略

`HashBasedShardingStrategy` 适用于需要均匀分布数据的场景，如用户名、邮箱等。

#### 使用示例

```python
from Modules.common.libs.database.sharding import HashBasedShardingStrategy

# 创建哈希分表策略（10个分表）
strategy = HashBasedShardingStrategy("username", bucket_count=10)

# 获取表名
table_name = strategy.get_table_name("user123", "users_")
print(table_name)  # users_5

# 获取所有表（哈希分表无法根据范围判断）
table_names = strategy.get_table_names_by_range("a", "z", "users_")
print(table_names)  # ['users_0', 'users_1', 'users_2', ..., 'users_9']
```

#### 适用场景

- 用户数据按用户名哈希分表
- 需要数据均匀分布的场景
- 无法预知数据增长趋势的场景
- 不需要范围查询的场景

## ShardingManager 使用

### 初始化管理器

```python
from Modules.common.libs.database.sharding import (
    ShardingManager,
    TimeBasedShardingStrategy,
)
from sqlmodel import SQLModel, Field
from datetime import date

# 定义模型
class QuantStockKline(SQLModel, table=True):
    __tablename__ = "quant_stock_klines_1d_2024"
    
    id: int = Field(default=None, primary_key=True)
    ts_code: str
    trade_date: date
    open: float
    high: float
    low: float
    close: float
    volume: float
    created_at: str = Field(default="")
    updated_at: str = Field(default="")

# 创建分表策略
strategy = TimeBasedShardingStrategy("trade_date", granularity="month")

# 初始化分表管理器
manager = ShardingManager(QuantStockKline, strategy)
```

### 表路由

```python
# 根据分表键值获取表名
table_name = manager.get_table_name(date(2024, 1, 15))
print(table_name)  # quant_stock_klines_1d_202401
```

### 表管理

```python
# 检查表是否存在
exists = manager.table_exists("quant_stock_klines_1d_202401")
print(exists)  # True/False

# 确保表存在（不存在则自动创建）
success = manager.ensure_table_exists("quant_stock_klines_1d_202401")
print(success)  # True

# 预热表（批量创建分表）
manager.warm_up_tables(["202401", "202402", "202403"])
```

### 数据查询

#### 单表查询

```python
# 查询单张表的数据
results = manager.query_single_table(
    table_name="quant_stock_klines_1d_202401",
    conditions={"ts_code": "000001.SZ"},
    limit=10,
    offset=0,
    order_by="trade_date DESC"
)

print(results)
```

#### 跨表查询

```python
# 查询多张表的数据
results = manager.query_multi_tables(
    sharding_key_range=(date(2024, 1, 1), date(2024, 3, 31)),
    conditions={"ts_code": "000001.SZ"},
    limit=100,
    order_by="trade_date DESC",
    max_tables=10
)

print(results)
```

#### 统计数据

```python
# 统计数据数量
count = manager.count(
    sharding_key_range=(date(2024, 1, 1), date(2024, 3, 31)),
    conditions={"ts_code": "000001.SZ"}
)

print(count)  # 90
```

### 数据写入

#### 插入单条数据

```python
# 插入单条数据
data = {
    "ts_code": "000001.SZ",
    "trade_date": date(2024, 1, 15),
    "open": 10.0,
    "high": 11.0,
    "low": 9.5,
    "close": 10.5,
    "volume": 1000000
}

success = manager.insert(
    sharding_key_value=date(2024, 1, 15),
    data=data,
    on_duplicate="UPDATE"
)

print(success)  # True
```

#### 批量插入

```python
# 批量插入数据
data_list = [
    {
        "ts_code": "000001.SZ",
        "trade_date": date(2024, 1, 15),
        "open": 10.0,
        "high": 11.0,
        "low": 9.5,
        "close": 10.5,
        "volume": 1000000
    },
    {
        "ts_code": "000001.SZ",
        "trade_date": date(2024, 1, 16),
        "open": 10.5,
        "high": 11.5,
        "low": 10.0,
        "close": 11.0,
        "volume": 1200000
    }
]

success_count = manager.batch_insert(
    data_list=data_list,
    on_duplicate="UPDATE"
)

print(success_count)  # 2
```

#### 更新数据

```python
# 更新数据
success = manager.update(
    sharding_key_value=date(2024, 1, 15),
    pk_values={"id": 1},
    data={"close": 11.0}
)

print(success)  # True
```

#### 插入或更新

```python
# 插入或更新数据（Upsert）
success = manager.upsert(
    sharding_key_value=date(2024, 1, 15),
    data={
        "ts_code": "000001.SZ",
        "trade_date": date(2024, 1, 15),
        "open": 10.0,
        "high": 11.0,
        "low": 9.5,
        "close": 10.5,
        "volume": 1000000
    }
)

print(success)  # True
```

## ShardingTableCreator 使用

### 初始化表创建器

```python
from Modules.common.libs.database.sharding import ShardingTableCreator
from sqlmodel import SQLModel, Field

# 定义模型
class QuantStockKline(SQLModel, table=True):
    __tablename__ = "quant_stock_klines_1d_2024"
    
    id: int = Field(default=None, primary_key=True)
    ts_code: str
    trade_date: str
    open: float
    high: float
    low: float
    close: float
    volume: float

# 初始化表创建器
table_creator = ShardingTableCreator(QuantStockKline)
```

### 创建分表

```python
# 创建分表
success = table_creator.create_sharded_table(
    table_suffix="202401",
    table_comment="2024年1月股票K线数据"
)

print(success)  # True
```

### 确保表存在

```python
# 确保表存在（使用分布式锁）
success = table_creator.ensure_table_exists(
    table_suffix="202401",
    table_comment="2024年1月股票K线数据"
)

print(success)  # True
```

### 批量创建表

```python
# 批量创建表
results = table_creator.batch_create_tables(
    suffixes=["202401", "202402", "202403"],
    table_comment="股票K线数据"
)

print(results)
# {
#     'quant_stock_klines_1d_202401': True,
#     'quant_stock_klines_1d_202402': True,
#     'quant_stock_klines_1d_202403': True
# }
```

### 检查表是否存在

```python
# 检查表是否存在
exists = table_creator.table_exists("quant_stock_klines_1d_202401")
print(exists)  # True
```

## ShardingCacheManager 使用

### 初始化缓存管理器

```python
from Modules.common.libs.database.sharding import ShardingCacheManager

# 初始化缓存管理器
cache_manager = ShardingCacheManager(
    cache_ttl=300,  # 缓存生存时间（秒）
    lock_timeout=60  # 锁超时时间（秒）
)
```

### 检查缓存可用性

```python
# 检查缓存是否可用
available = cache_manager.is_cache_available()
print(available)  # True/False
```

### 表存在性缓存

```python
# 检查表是否存在（带缓存）
def check_table_exists(table_name):
    # 模拟数据库检查
    return True

exists = cache_manager.check_table_exists_with_cache(
    table_name="quant_stock_klines_1d_202401",
    check_db_func=check_table_exists
)

print(exists)  # True
```

### 分布式锁

```python
# 获取分布式锁
acquired = cache_manager.acquire_lock("quant_stock_klines_1d_202401")
print(acquired)  # True/False

if acquired:
    try:
        # 执行需要锁的操作
        print("执行操作...")
    finally:
        # 释放锁
        cache_manager.release_lock("quant_stock_klines_1d_202401")
```

## 实际应用场景

### 1. 股票 K 线数据分表

```python
from datetime import date
from Modules.common.libs.database.sharding import (
    ShardingManager,
    TimeBasedShardingStrategy,
)
from sqlmodel import SQLModel, Field

# 定义模型
class QuantStockKline(SQLModel, table=True):
    __tablename__ = "quant_stock_klines_1d_2024"
    
    id: int = Field(default=None, primary_key=True)
    ts_code: str
    trade_date: date
    open: float
    high: float
    low: float
    close: float
    volume: float
    created_at: str = Field(default="")
    updated_at: str = Field(default="")

# 创建分表策略（按月分表）
strategy = TimeBasedShardingStrategy("trade_date", granularity="month")

# 初始化分表管理器
manager = ShardingManager(QuantStockKline, strategy)

# 插入股票 K 线数据
kline_data = {
    "ts_code": "000001.SZ",
    "trade_date": date(2024, 1, 15),
    "open": 10.0,
    "high": 11.0,
    "low": 9.5,
    "close": 10.5,
    "volume": 1000000
}

manager.insert(date(2024, 1, 15), kline_data)

# 查询指定日期范围的 K 线数据
results = manager.query_multi_tables(
    sharding_key_range=(date(2024, 1, 1), date(2024, 3, 31)),
    conditions={"ts_code": "000001.SZ"},
    order_by="trade_date DESC"
)

print(results)
```

### 2. 用户数据分表

```python
from Modules.common.libs.database.sharding import (
    ShardingManager,
    IdBasedShardingStrategy,
)
from sqlmodel import SQLModel, Field

# 定义模型
class User(SQLModel, table=True):
    __tablename__ = "users_0"
    
    id: int = Field(default=None, primary_key=True)
    username: str
    email: str
    age: int
    created_at: str = Field(default="")
    updated_at: str = Field(default="")

# 创建分表策略（按取模分表，10个表）
strategy = IdBasedShardingStrategy("id", mode="mod", mod_value=10)

# 初始化分表管理器
manager = ShardingManager(User, strategy)

# 插入用户数据
user_data = {
    "id": 123,
    "username": "user123",
    "email": "user123@example.com",
    "age": 30
}

manager.insert(123, user_data)

# 查询用户
results = manager.query_single_table(
    table_name="users_3",  # 123 % 10 = 3
    conditions={"id": 123}
)

print(results)
```

### 3. 订单数据分表

```python
from datetime import date
from Modules.common.libs.database.sharding import (
    ShardingManager,
    IdBasedShardingStrategy,
)
from sqlmodel import SQLModel, Field

# 定义模型
class Order(SQLModel, table=True):
    __tablename__ = "orders_0"
    
    id: int = Field(default=None, primary_key=True)
    user_id: int
    order_date: date
    amount: float
    status: str
    created_at: str = Field(default="")
    updated_at: str = Field(default="")

# 创建分表策略（按范围分表，每1000条一个表）
strategy = IdBasedShardingStrategy("id", mode="range", range_size=1000)

# 初始化分表管理器
manager = ShardingManager(Order, strategy)

# 批量插入订单数据
order_list = [
    {
        "id": 1001,
        "user_id": 123,
        "order_date": date(2024, 1, 15),
        "amount": 100.0,
        "status": "completed"
    },
    {
        "id": 1002,
        "user_id": 456,
        "order_date": date(2024, 1, 16),
        "amount": 200.0,
        "status": "pending"
    }
]

success_count = manager.batch_insert(order_list)
print(f"成功插入 {success_count} 条订单")

# 查询指定 ID 范围的订单
results = manager.query_multi_tables(
    sharding_key_range=(1000, 2000),
    conditions={"user_id": 123},
    order_by="id DESC"
)

print(results)
```

### 4. 日志数据分表

```python
from datetime import date
from Modules.common.libs.database.sharding import (
    ShardingManager,
    TimeBasedShardingStrategy,
)
from sqlmodel import SQLModel, Field

# 定义模型
class Log(SQLModel, table=True):
    __tablename__ = "logs_2024"
    
    id: int = Field(default=None, primary_key=True)
    level: str
    message: str
    log_date: date
    created_at: str = Field(default="")

# 创建分表策略（按日分表）
strategy = TimeBasedShardingStrategy("log_date", granularity="day")

# 初始化分表管理器
manager = ShardingManager(Log, strategy)

# 插入日志数据
log_data = {
    "level": "INFO",
    "message": "User login",
    "log_date": date(2024, 1, 15)
}

manager.insert(date(2024, 1, 15), log_data)

# 查询指定日期范围的日志
results = manager.query_multi_tables(
    sharding_key_range=(date(2024, 1, 1), date(2024, 1, 31)),
    conditions={"level": "ERROR"},
    order_by="log_date DESC",
    limit=100
)

print(results)
```

### 5. 数据预热

```python
from datetime import date
from Modules.common.libs.database.sharding import (
    ShardingManager,
    TimeBasedShardingStrategy,
)
from sqlmodel import SQLModel, Field

# 定义模型
class QuantStockKline(SQLModel, table=True):
    __tablename__ = "quant_stock_klines_1d_2024"
    
    id: int = Field(default=None, primary_key=True)
    ts_code: str
    trade_date: date
    open: float
    high: float
    low: float
    close: float
    volume: float

# 创建分表策略
strategy = TimeBasedShardingStrategy("trade_date", granularity="month")

# 初始化分表管理器
manager = ShardingManager(QuantStockKline, strategy)

# 预热未来3个月的表
from datetime import datetime, timedelta

def generate_month_suffixes(months):
    """生成未来几个月的表名后缀"""
    suffixes = []
    current_date = datetime.now()
    for i in range(months):
        future_date = current_date + timedelta(days=30 * i)
        suffix = future_date.strftime("%Y%m")
        suffixes.append(suffix)
    return suffixes

# 预热表
suffixes = generate_month_suffixes(12)
manager.warm_up_tables(suffixes)

print(f"已预热表: {suffixes}")
```

## 最佳实践

### 1. 选择合适的分表策略

根据业务场景选择合适的分表策略：

```python
# 时间序列数据：使用时间分表
TimeBasedShardingStrategy("trade_date", granularity="month")

# 用户数据：使用 ID 取模分表
IdBasedShardingStrategy("user_id", mode="mod", mod_value=10)

# 订单数据：使用 ID 范围分表
IdBasedShardingStrategy("order_id", mode="range", range_size=1000)

# 需要均匀分布：使用哈希分表
HashBasedShardingStrategy("username", bucket_count=10)
```

### 2. 合理设置时间粒度

根据数据量和查询频率设置合适的时间粒度：

```python
# 数据量大、查询频繁：按日分表
TimeBasedShardingStrategy("trade_date", granularity="day")

# 数据量中等：按月分表
TimeBasedShardingStrategy("trade_date", granularity="month")

# 数据量小：按年分表
TimeBasedShardingStrategy("trade_date", granularity="year")
```

### 3. 使用批量操作提高性能

对于大量数据插入，使用批量操作：

```python
# 不推荐：循环单条插入
for data in data_list:
    manager.insert(sharding_key_value, data)

# 推荐：批量插入
manager.batch_insert(data_list)
```

### 4. 预热分表

避免运行时动态创建表，提前预热分表：

```python
# 应用启动时预热分表
def warm_up_sharding_tables():
    # 预热未来12个月的表
    suffixes = generate_month_suffixes(12)
    manager.warm_up_tables(suffixes)

# 在应用启动时调用
warm_up_sharding_tables()
```

### 5. 限制跨表查询

跨表查询性能较差，应限制查询的表数量：

```python
# 限制查询表数量
results = manager.query_multi_tables(
    sharding_key_range=(date(2024, 1, 1), date(2024, 12, 31)),
    conditions={"ts_code": "000001.SZ"},
    max_tables=50  # 最多查询50张表
)
```

### 6. 使用缓存提高性能

利用缓存减少数据库查询：

```python
# 缓存会自动启用
# 检查表是否存在时会先查缓存
exists = manager.table_exists("table_name")

# 缓存 TTL 默认为 300 秒
# 可以在 ShardingCacheManager 中自定义
cache_manager = ShardingCacheManager(cache_ttl=600)
```

### 7. 错误处理和日志记录

合理处理异常和记录日志：

```python
from loguru import logger

try:
    success = manager.insert(sharding_key_value, data)
    if success:
        logger.info(f"数据插入成功: {sharding_key_value}")
    else:
        logger.warning(f"数据插入失败: {sharding_key_value}")
except Exception as e:
    logger.error(f"数据插入异常: {e}")
    # 根据业务需求进行降级处理
```

### 8. 数据迁移和归档

定期归档旧数据：

```python
from datetime import date, timedelta

def archive_old_data():
    """归档旧数据"""
    # 归档6个月前的数据
    archive_date = date.today() - timedelta(days=180)
    
    # 查询需要归档的数据
    results = manager.query_multi_tables(
        sharding_key_range=(date(2020, 1, 1), archive_date),
        limit=10000
    )
    
    # 将数据导出到归档存储
    export_to_archive(results)
    
    # 删除已归档的数据
    # （需要根据业务需求实现）
```

## 常见问题

### Q: 如何选择分表策略？

A: 根据业务场景选择：

- **时间序列数据**（日志、交易记录）：使用 `TimeBasedShardingStrategy`
- **用户数据**（用户信息、用户设置）：使用 `IdBasedShardingStrategy`（取模）
- **订单数据**（订单、支付记录）：使用 `IdBasedShardingStrategy`（范围）
- **需要均匀分布**（用户名、邮箱）：使用 `HashBasedShardingStrategy`

### Q: 如何处理跨表查询性能问题？

A: 跨表查询性能较差，建议：

1. 限制查询的表数量（使用 `max_tables` 参数）
2. 尽量缩小查询范围
3. 考虑使用数据仓库或 OLAP 系统进行复杂查询
4. 对热点数据建立汇总表

```python
# 限制查询表数量
results = manager.query_multi_tables(
    sharding_key_range=(date(2024, 1, 1), date(2024, 3, 31)),
    max_tables=10  # 最多查询10张表
)
```

### Q: 如何处理数据迁移？

A: 数据迁移建议：

1. 使用批量操作提高迁移效率
2. 分批迁移，避免长时间锁表
3. 迁移前备份数据
4. 迁移后验证数据一致性

```python
def migrate_data(source_manager, target_manager, batch_size=1000):
    """迁移数据"""
    offset = 0
    while True:
        # 批量读取数据
        results = source_manager.query_multi_tables(
            sharding_key_range=(date(2020, 1, 1), date(2020, 12, 31)),
            limit=batch_size,
            offset=offset
        )
        
        if not results:
            break
        
        # 批量写入目标表
        target_manager.batch_insert(results)
        
        offset += batch_size
        print(f"已迁移 {offset} 条数据")
```

### Q: 如何处理表不存在的情况？

A: 管理器会自动处理表不存在的情况：

```python
# ensure_table_exists 会自动创建表
manager.ensure_table_exists(table_name)

# insert 也会自动创建表
manager.insert(sharding_key_value, data)
```

### Q: 如何处理分布式锁超时？

A: 分布式锁默认超时时间为 60 秒，可以自定义：

```python
# 自定义锁超时时间
cache_manager = ShardingCacheManager(lock_timeout=120)  # 120秒
```

### Q: 如何监控分表性能？

A: 可以通过日志和统计信息监控：

```python
from loguru import logger
import time

def monitored_insert(manager, sharding_key_value, data):
    """带监控的插入操作"""
    start_time = time.time()
    
    try:
        success = manager.insert(sharding_key_value, data)
        elapsed = time.time() - start_time
        
        logger.info(f"插入成功 - 耗时: {elapsed:.4f}s, 分表键: {sharding_key_value}")
        return success
    except Exception as e:
        elapsed = time.time() - start_time
        logger.error(f"插入失败 - 耗时: {elapsed:.4f}s, 错误: {e}")
        raise
```

## API 参考

### ShardingManager 类方法

| 方法 | 描述 | 返回值 |
|------|------|--------|
| `get_table_name(sharding_key_value)` | 根据分表键值获取表名 | str |
| `table_exists(table_name)` | 检查表是否存在（带缓存） | bool |
| `ensure_table_exists(table_name)` | 确保表存在 | bool |
| `warm_up_tables(suffixes)` | 预热表 | None |
| `query_single_table(table_name, conditions, limit, offset, order_by)` | 查询单张表的数据 | list[dict] |
| `query_multi_tables(sharding_key_range, conditions, limit, order_by, max_tables)` | 查询多张表的数据 | list[dict] |
| `count(sharding_key_range, conditions)` | 统计数据数量 | int |
| `insert(sharding_key_value, data, on_duplicate)` | 插入单条数据 | bool |
| `batch_insert(data_list, on_duplicate)` | 批量插入数据 | int |
| `update(sharding_key_value, pk_values, data)` | 更新数据 | bool |
| `upsert(sharding_key_value, data)` | 插入或更新数据 | bool |

### ShardingTableCreator 类方法

| 方法 | 描述 | 返回值 |
|------|------|--------|
| `create_sharded_table(table_suffix, table_comment)` | 创建分表 | bool |
| `ensure_table_exists(table_suffix, table_comment)` | 确保表存在 | bool |
| `batch_create_tables(suffixes, table_comment)` | 批量创建表 | dict[str, bool] |
| `table_exists(table_name)` | 检查表是否存在 | bool |

### ShardingCacheManager 类方法

| 方法 | 描述 | 返回值 |
|------|------|--------|
| `is_cache_available()` | 检查缓存是否可用 | bool |
| `check_table_exists_with_cache(table_name, check_db_func)` | 检查表是否存在（带缓存） | bool |
| `acquire_lock(table_name)` | 获取分布式锁 | bool |
| `release_lock(table_name)` | 释放分布式锁 | bool |

### 分表策略

#### TimeBasedShardingStrategy

| 参数 | 描述 | 默认值 |
|------|------|--------|
| `sharding_key` | 分表键字段名 | - |
| `granularity` | 时间粒度（year/month/day） | year |

#### IdBasedShardingStrategy

| 参数 | 描述 | 默认值 |
|------|------|--------|
| `sharding_key` | 分表键字段名 | - |
| `mode` | 分表方式（range/mod） | mod |
| `mod_value` | 取模值 | None |
| `range_size` | 范围大小 | None |

#### HashBasedShardingStrategy

| 参数 | 描述 | 默认值 |
|------|------|--------|
| `sharding_key` | 分表键字段名 | - |
| `bucket_count` | 分桶数量 | 10 |
| `hash_algorithm` | 哈希算法（md5/sha1/sha256） | md5 |

## 版本历史

- v1.0.0: 初始版本，提供基本的分表功能
- v1.1.0: 添加缓存支持和分布式锁
- v1.2.0: 增强批量操作和错误处理
- v1.3.0: 添加多种分表策略支持
