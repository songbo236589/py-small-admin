# 知乎话题获取功能实现文档

> 参考知乎创作中心推荐问题页面：https://www.zhihu.com/creator/featured-question/recommend

---

## 目录

- [一、功能概述](#一功能概述)
- [二、数据库设计](#二数据库设计)
- [三、后端实现](#三后端实现)
- [四、前端实现](#四前端实现)
- [五、API 接口文档](#五-api-接口文档)
- [六、使用流程](#六使用流程)
- [七、扩展计划](#七扩展计划)
- [附录](#附录)

---

## 一、功能概述

### 1.1 功能目标

实现从知乎平台获取推荐问题/话题，帮助用户快速找到写作灵感，辅助 AI 写作功能。

### 1.2 核心功能

| 功能 | 描述 |
|------|------|
| **话题抓取** | 从知乎推荐问题页面抓取热门话题（手动触发） |
| **话题存储** | 将抓取的话题存储到数据库，支持去重 |
| **话题展示** | 在管理后台展示已抓取的话题列表 |
| **话题使用** | 选择话题后自动填充到文章编辑表单 |
| **状态管理** | 支持话题的收藏、使用状态标记 |

### 1.3 技术特点

- **手动触发**：用户主动点击按钮抓取，按需使用
- **同步处理**：抓取过程用户可见，有 Loading 状态提示
- **去重机制**：自动过滤已存在的话题，支持数据更新
- **热度计算**：根据浏览量和回答数计算话题热度

### 1.4 技术架构

```
┌─────────────────────────────────────────────────────────────┐
│                         前端 (React + Ant Design Pro)        │
├─────────────────────────────────────────────────────────────┤
│  抓取按钮 │ FetchModal │ TopicList │ TopicDrawer │ TopicCard │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼ 点击抓取
┌─────────────────────────────────────────────────────────────┐
│                      后端 API (FastAPI)                      │
├─────────────────────────────────────────────────────────────┤
│  GET  /api/content/topics/fetch   - 抓取新话题（同步）        │
│  GET  /api/content/topics         - 话题列表                │
│  POST /api/content/topics/:id/use - 使用话题                │
│  POST /api/content/topics/:id/favorite - 收藏话题            │
│  GET  /api/content/topics/:id     - 话题详情                │
│  DELETE /api/content/topics/:id   - 删除话题                │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    服务层 (Service Layer)                    │
├─────────────────────────────────────────────────────────────┤
│              TopicService                                   │
│  - fetch_topics()    - 同步抓取话题                          │
│  - list_topics()     - 查询列表                              │
│  - use_topic()       - 使用话题                              │
│  - favorite()        - 收藏话题                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  处理器层 (Handler Layer)                    │
├─────────────────────────────────────────────────────────────┤
│              ZhihuHandler                                   │
│  - fetch_recommended_questions() - 获取推荐问题             │
│  - _parse_zhihu_number() - 解析数字格式                     │
│  - _extract_question_id_from_url() - 提取问题ID            │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  数据模型 (Model Layer)                      │
├─────────────────────────────────────────────────────────────┤
│              ContentTopic                                   │
│  - 话题ID、标题、描述、URL、浏览量、回答数、分类等            │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  知乎平台 (Zhihu.com)                        │
│         访问创作中心推荐问题页面并解析数据                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、数据库设计

### 2.1 数据表结构

```sql
CREATE TABLE `content_topics` (
  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `platform` VARCHAR(20) NOT NULL COMMENT '平台标识：zhihu',
  `platform_question_id` VARCHAR(50) NOT NULL COMMENT '平台问题ID',
  `title` VARCHAR(500) NOT NULL COMMENT '问题标题',
  `description` TEXT NULL COMMENT '问题描述',
  `url` VARCHAR(500) NULL COMMENT '问题链接',
  `view_count` INT UNSIGNED DEFAULT 0 COMMENT '浏览量',
  `answer_count` INT UNSIGNED DEFAULT 0 COMMENT '回答数',
  `follower_count` INT UNSIGNED DEFAULT 0 COMMENT '关注者数',
  `category` VARCHAR(100) NULL COMMENT '分类/话题标签',
  `hot_score` INT UNSIGNED NULL COMMENT '热度分数',
  `author_name` VARCHAR(100) NULL COMMENT '提问者昵称',
  `author_url` VARCHAR(200) NULL COMMENT '提问者主页',
  `status` TINYINT NOT NULL DEFAULT 0 COMMENT '状态: 0=未使用, 1=已使用, 2=已收藏',
  `fetched_at` DATETIME NOT NULL COMMENT '抓取时间',
  `created_at` DATETIME NOT NULL COMMENT '创建时间',
  `updated_at` DATETIME NULL COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_platform_question` (`platform`, `platform_question_id`),
  KEY `idx_platform_status` (`platform`, `status`),
  KEY `idx_hot_score` (`hot_score` DESC),
  KEY `idx_fetched_at` (`fetched_at` DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='话题/问题表';
```

### 2.2 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | INT UNSIGNED | 主键 ID |
| `platform` | VARCHAR(20) | 平台标识（zhihu、jianshu 等） |
| `platform_question_id` | VARCHAR(50) | 平台问题唯一 ID |
| `title` | VARCHAR(500) | 问题标题 |
| `description` | TEXT | 问题描述详情 |
| `url` | VARCHAR(500) | 问题页面链接 |
| `view_count` | INT UNSIGNED | 浏览量 |
| `answer_count` | INT UNSIGNED | 回答数量 |
| `follower_count` | INT UNSIGNED | 关注者数量 |
| `category` | VARCHAR(100) | 分类/话题标签 |
| `hot_score` | INT UNSIGNED | 热度分数（可自定义计算） |
| `author_name` | VARCHAR(100) | 提问者昵称 |
| `author_url` | VARCHAR(200) | 提问者主页链接 |
| `status` | TINYINT | 状态：0=未使用, 1=已使用, 2=已收藏 |
| `fetched_at` | DATETIME | 抓取时间 |
| `created_at` | DATETIME | 创建时间 |
| `updated_at` | DATETIME | 更新时间 |

### 2.3 索引设计

| 索引名 | 字段 | 说明 |
|--------|------|------|
| `PRIMARY` | `id` | 主键索引 |
| `uk_platform_question` | `platform, platform_question_id` | 唯一索引，防止重复抓取 |
| `idx_platform_status` | `platform, status` | 平台状态索引 |
| `idx_hot_score` | `hot_score` | 热度排序索引 |
| `idx_fetched_at` | `fetched_at` | 时间排序索引 |

---

## 三、后端实现

### 3.1 数据模型

#### 文件：`server/Modules/content/models/content_topic.py`

```python
"""
话题/问题模型

对应数据库表：content_topics
"""

from datetime import datetime
from typing import Optional

from sqlalchemy import Column, DateTime, Index, SmallInteger, String, Text
from sqlalchemy.dialects.mysql import INTEGER
from sqlmodel import Field

from Modules.common.models.base_model import BaseTableModel


class ContentTopic(BaseTableModel, table=True):
    """
    话题/问题模型

    对应数据库表 content_topics，存储从第三方平台抓取的话题/问题信息。
    """

    # 表注释
    __table_comment__ = "话题/问题表，存储从第三方平台抓取的话题/问题信息"

    id: int | None = Field(
        sa_column=Column(
            INTEGER(unsigned=True),
            primary_key=True,
            autoincrement=True,
            comment="主键 ID",
        ),
        default=None,
    )

    # 平台标识
    platform: str = Field(
        sa_column=Column(
            String(20), nullable=False, comment="平台标识：zhihu"
        ),
        default="",
        index=True,
    )

    # 平台问题ID
    platform_question_id: str = Field(
        sa_column=Column(
            String(50), nullable=False, comment="平台问题ID"
        ),
        default="",
    )

    # 问题标题
    title: str = Field(
        sa_column=Column(
            String(500), nullable=False, comment="问题标题"
        ),
        default="",
    )

    # 问题描述
    description: str | None = Field(
        sa_column=Column(
            Text, nullable=True, comment="问题描述"
        ),
        default=None,
    )

    # 问题链接
    url: str | None = Field(
        sa_column=Column(
            String(500), nullable=True, comment="问题链接"
        ),
        default=None,
    )

    # 浏览量
    view_count: int = Field(
        sa_column=Column(
            INTEGER(unsigned=True),
            nullable=False,
            server_default="0",
            comment="浏览量",
        ),
        default=0,
    )

    # 回答数
    answer_count: int = Field(
        sa_column=Column(
            INTEGER(unsigned=True),
            nullable=False,
            server_default="0",
            comment="回答数",
        ),
        default=0,
    )

    # 关注者数
    follower_count: int = Field(
        sa_column=Column(
            INTEGER(unsigned=True),
            nullable=False,
            server_default="0",
            comment="关注者数",
        ),
        default=0,
    )

    # 分类/话题标签
    category: str | None = Field(
        sa_column=Column(
            String(100), nullable=True, comment="分类/话题标签"
        ),
        default=None,
    )

    # 热度分数
    hot_score: int | None = Field(
        sa_column=Column(
            INTEGER(unsigned=True),
            nullable=True,
            comment="热度分数",
        ),
        default=None,
    )

    # 提问者昵称
    author_name: str | None = Field(
        sa_column=Column(
            String(100), nullable=True, comment="提问者昵称"
        ),
        default=None,
    )

    # 提问者主页
    author_url: str | None = Field(
        sa_column=Column(
            String(200), nullable=True, comment="提问者主页"
        ),
        default=None,
    )

    # 状态: 0=未使用, 1=已使用, 2=已收藏
    status: int = Field(
        sa_column=Column(
            SmallInteger,
            nullable=False,
            server_default="0",
            comment="状态: 0=未使用, 1=已使用, 2=已收藏",
            index=True,
        ),
        default=0,
    )

    # 抓取时间
    fetched_at: datetime | None = Field(
        sa_column=Column(
            DateTime(), nullable=False, comment="抓取时间", index=True
        ),
        default=None,
    )

    created_at: datetime | None = Field(
        sa_column=Column(DateTime(), nullable=False, comment="创建时间"),
        default=None,
    )

    updated_at: datetime | None = Field(
        sa_column=Column(DateTime(), nullable=True, comment="更新时间"),
        default=None,
    )

    # 索引
    __table_args__ = (
        Index("uk_platform_question", "platform", "platform_question_id", unique=True),
        Index("idx_platform_status", "platform", "status"),
        Index("idx_hot_score", "hot_score"),
    )

    class Config:
        """Pydantic配置"""

        from_attributes = True
```

### 3.2 Handler 扩展

#### 文件：`server/Modules/content/services/publisher/zhihu_handler.py`

在现有的 `ZhihuHandler` 类中添加以下方法：

```python
async def fetch_recommended_questions(
    self,
    limit: int = 20,
    category: str | None = None,
) -> list[dict]:
    """获取知乎推荐问题列表

    从知乎创作中心推荐问题页面抓取热门话题。

    Args:
        limit: 获取数量，默认20条
        category: 分类筛选（可选）

    Returns:
        问题列表，每项包含:
        - question_id: 问题ID
        - title: 问题标题
        - description: 问题描述
        - url: 问题链接
        - view_count: 浏览量
        - answer_count: 回答数
        - follower_count: 关注者数
        - category: 分类
        - author_name: 提问者昵称
    """
    from Modules.common.libs.config.registry import ConfigRegistry

    assert self.page is not None, "页面未初始化"

    config = ConfigRegistry.get("content")
    questions = []

    try:
        # 1. 访问知乎创作中心推荐问题页面
        logger.info("[知乎] 正在访问推荐问题页面...")
        recommend_url = "https://www.zhihu.com/creator/featured-question/recommend"
        await self.page.goto(recommend_url, timeout=10000)
        await self.page.wait_for_load_state("networkidle", timeout=10000)

        # 2. 检查登录状态
        is_logged_in = await self.check_login_status()
        if not is_logged_in:
            logger.error("[知乎] 未登录，无法获取推荐问题")
            raise Exception("知乎账号未登录，请先验证账号状态")

        logger.info("[知乎] ✓ 已登录，开始抓取推荐问题...")

        # 3. 等待问题列表加载
        # 知乎推荐问题页的选择器可能需要根据实际页面调整
        question_selectors = [
            ".QuestionItem",           # 可能的问题卡片选择器
            '[data-zop="listitem"]',   # 另一种可能的选择器
            ".QuestionList-item",      # 列表项选择器
            ".Card-item",              # 卡片项选择器
        ]

        question_items = None
        for selector in question_selectors:
            try:
                question_items = await self.page.wait_for_selector(
                    f"{selector}:nth-of-type(1)", timeout=5000, state="visible"
                )
                if question_items:
                    logger.info(f"[知乎] ✓ 找到问题列表: {selector}")
                    break
            except Exception:
                logger.debug(f"[知乎] 选择器未找到: {selector}")
                continue

        if not question_items:
            logger.warning("[知乎] 未找到问题列表，尝试通过 API 获取...")
            # 如果页面选择器失败，可以尝试拦截网络请求获取 API 数据
            return await self._fetch_questions_via_api(limit, category)

        # 4. 提取问题数据
        logger.info("[知乎] 正在解析问题数据...")
        question_elements = await self.page.query_selector_all(question_selectors[0])

        for i, elem in enumerate(question_elements[:limit]):
            try:
                # 提取问题标题
                title_elem = await elem.query_selector(".QuestionItem-title a, .QuestionTitle a")
                title = await title_elem.inner_text() if title_elem else ""

                # 提取问题链接
                url = await title_elem.get_attribute("href") if title_elem else ""
                if url and not url.startswith("http"):
                    url = "https://www.zhihu.com" + url

                # 提取问题描述
                desc_elem = await elem.query_selector(".QuestionItem-detail, .QuestionDetail")
                description = await desc_elem.inner_text() if desc_elem else ""

                # 提取浏览量、回答数等数据
                # 知乎的数字显示可能需要解析（如 "1.2万" -> 12000）
                stats_elem = await elem.query_selector(".QuestionItem-stats, .QuestionStats")
                stats_text = await stats_elem.inner_text() if stats_elem else ""

                # 解析统计数据
                view_count = self._parse_zhihu_number(stats_text)
                answer_count = self._parse_zhihu_number(stats_text, "回答")

                # 提取分类标签
                category_elem = await elem.query_selector(".Tag, .Category")
                category_name = await category_elem.inner_text() if category_elem else None

                # 从 URL 中提取问题 ID
                question_id = self._extract_question_id_from_url(url) if url else ""

                if title and question_id:
                    questions.append({
                        "question_id": question_id,
                        "title": title.strip(),
                        "description": description.strip() if description else None,
                        "url": url,
                        "view_count": view_count,
                        "answer_count": answer_count,
                        "follower_count": 0,  # 暂未获取
                        "category": category_name,
                        "hot_score": view_count + answer_count * 10,  # 简单热度计算
                        "author_name": None,
                    })
                    logger.debug(f"[知乎] ✓ 解析问题 {i+1}: {title[:30]}...")

            except Exception as e:
                logger.warning(f"[知乎] 解析问题 {i+1} 时出错: {str(e)}")
                continue

        logger.info(f"[知乎] ✓ 成功抓取 {len(questions)} 个推荐问题")

    except Exception as e:
        logger.error(f"[知乎] ✗ 抓取推荐问题时出错: {str(e)}", exc_info=True)
        raise

    return questions


async def _fetch_questions_via_api(
    self, limit: int = 20, category: str | None = None
) -> list[dict]:
    """通过 API 获取推荐问题（备用方案）

    当页面解析失败时，尝试通过拦截网络请求获取 API 数据。
    """
    questions = []

    try:
        # 监听网络响应
        async with self.page.expect_response(
            lambda response: "creator" in response.url and "json" in response.headers.get("content-type", ""),
            timeout=10000
        ) as response_info:
            await self.page.reload()
            response = await response_info.value

        if response.ok:
            data = await response.json()
            # 解析 API 返回的数据结构
            # 这里需要根据实际的 API 响应结构进行解析
            logger.info(f"[知乎] 通过 API 获取到数据: {data}")

    except Exception as e:
        logger.warning(f"[知乎] API 获取失败: {str(e)}")

    return questions


def _parse_zhihu_number(self, text: str, keyword: str = "") -> int:
    """解析知乎的数字格式

    Args:
        text: 包含数字的文本
        keyword: 关键词筛选（如"回答"）

    Returns:
        解析后的整数值

    Examples:
        "1.2万" -> 12000
        "356" -> 356
    """
    import re

    if keyword and keyword not in text:
        return 0

    # 匹配数字格式：356、1.2万、3.5k 等
    patterns = [
        r"(\d+\.\d+)万",  # 1.2万
        r"(\d+)万",       # 12万
        r"(\d+\.\d+)k",   # 1.2k
        r"(\d+)k",        # 12k
        r"(\d+)",         # 356
    ]

    for pattern in patterns:
        match = re.search(pattern, text)
        if match:
            num_str = match.group(1)
            num = float(num_str) if "." in num_str else int(num_str)

            # 根据单位转换
            if "万" in match.group(0):
                return int(num * 10000)
            elif "k" in match.group(0).lower():
                return int(num * 1000)
            return int(num)

    return 0


def _extract_question_id_from_url(self, url: str) -> str | None:
    """从知乎问题 URL 中提取问题 ID

    Args:
        url: 知乎问题 URL

    Returns:
        问题 ID

    Examples:
        https://www.zhihu.com/question/123456 -> 123456
    """
    import re

    patterns = [
        r"/question/(\d+)",
        r"/p/(\d+)",
    ]

    for pattern in patterns:
        match = re.search(pattern, url)
        if match:
            return match.group(1)

    return None
```

### 3.3 服务层

#### 文件：`server/Modules/content/services/topic_service.py`

```python
"""
Content 话题服务 - 负责话题抓取和管理的业务逻辑
"""

import json
from typing import Any

from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
from fastapi_pagination.ext.sqlmodel import paginate
from sqlmodel import select

from Modules.common.libs.database.sql.session import get_async_session
from Modules.common.libs.responses.response import error, success
from Modules.common.libs.time.utils import format_datetime, now
from Modules.common.libs.validation.pagination_validator import CustomParams
from Modules.common.services.base_service import BaseService
from Modules.content.models.content_platform_account import ContentPlatformAccount
from Modules.content.models.content_topic import ContentTopic
from Modules.content.services.publisher import ZhihuHandler


class TopicService(BaseService):
    """Content话题服务 - 负责话题抓取和管理的业务逻辑"""

    def __init__(self):
        super().__init__()

    async def fetch_topics(
        self, platform: str, platform_account_id: int, limit: int = 20
    ) -> JSONResponse:
        """从指定平台获取推荐话题（同步执行）

        Args:
            platform: 平台标识（zhihu）
            platform_account_id: 平台账号ID
            limit: 获取数量

        Returns:
            JSONResponse: 抓取结果
        """
        # 1. 验证平台账号
        async with get_async_session() as session:
            account_result = await session.execute(
                select(ContentPlatformAccount).where(
                    ContentPlatformAccount.id == platform_account_id,
                    ContentPlatformAccount.platform == platform,
                    ContentPlatformAccount.status == 1,  # 1=有效
                )
            )
            account = account_result.scalar_one_or_none()

            if not account:
                return error("平台账号不存在或已失效")

            # 2. 解析 Cookies
            try:
                cookies = json.loads(account.cookies) if account.cookies else []
            except json.JSONDecodeError:
                return error("Cookie 格式错误，无法解析")

            # 3. 获取对应的处理器
            handlers = {
                "zhihu": ZhihuHandler,
            }

            handler_class = handlers.get(platform)
            if not handler_class:
                return error(f"不支持的平台: {platform}")

            # 4. 执行抓取（同步等待完成）
            try:
                handler = handler_class(cookies=cookies, user_agent=account.user_agent)
                questions = await handler.fetch_recommended_questions(limit=limit)

                # 5. 存储到数据库（去重）
                created_count = 0
                updated_count = 0
                skipped_count = 0

                for q in questions:
                    # 检查是否已存在
                    existing = await session.execute(
                        select(ContentTopic).where(
                            ContentTopic.platform == platform,
                            ContentTopic.platform_question_id == q["question_id"],
                        )
                    )
                    existing_topic = existing.scalar_one_or_none()

                    topic_data = {
                        "platform": platform,
                        "platform_question_id": q["question_id"],
                        "title": q["title"],
                        "description": q.get("description"),
                        "url": q.get("url"),
                        "view_count": q.get("view_count", 0),
                        "answer_count": q.get("answer_count", 0),
                        "follower_count": q.get("follower_count", 0),
                        "category": q.get("category"),
                        "hot_score": q.get("hot_score"),
                        "author_name": q.get("author_name"),
                        "author_url": None,
                        "fetched_at": now(),
                    }

                    if existing_topic:
                        # 更新已存在的话题
                        for key, value in topic_data.items():
                            setattr(existing_topic, key, value)
                        updated_count += 1
                    else:
                        # 创建新话题
                        new_topic = ContentTopic(**topic_data)
                        new_topic.created_at = now()
                        session.add(new_topic)
                        created_count += 1

                await session.commit()

                return success(
                    {
                        "total": len(questions),
                        "created": created_count,
                        "updated": updated_count,
                        "skipped": skipped_count,
                        "platform": platform,
                        "message": f"成功抓取 {len(questions)} 个话题（新增 {created_count} 个，更新 {updated_count} 个）",
                    }
                )

            except Exception as e:
                return error(f"抓取失败: {str(e)}")

    async def index(self, data: dict[str, Any]) -> JSONResponse:
        """获取话题列表或搜索话题（统一接口）"""
        page = data.get("page", 1)
        size = data.get("limit", 20)

        # 模糊匹配字段字典
        data["fuzzy_fields"] = ["title", "category", "author_name"]
        # 精确匹配字段字典
        data["exact_fields"] = ["platform", "status"]
        # 应用范围筛选
        data["range_fields"] = ["hot_score", "view_count", "answer_count", "fetched_at"]

        async with get_async_session() as session:
            # 构建基础查询
            query = select(ContentTopic)

            # 搜索
            query = await self.apply_search_filters(query, ContentTopic, data)

            # 应用排序（默认按热度降序）
            if not data.get("sort"):
                query = query.order_by(ContentTopic.hot_score.desc())  # type: ignore
            else:
                query = await self.apply_sorting(query, ContentTopic, data.get("sort"))

            page_data = await paginate(
                session, query, CustomParams(page=page, size=size)
            )
            items = []
            for topic in page_data.items:
                d = topic.__dict__.copy()
                d["fetched_at"] = (
                    format_datetime(topic.fetched_at) if topic.fetched_at else None
                )
                d["created_at"] = (
                    format_datetime(topic.created_at) if topic.created_at else None
                )
                items.append(d)

            return success(
                jsonable_encoder(
                    {
                        "items": items,
                        "total": page_data.total,
                        "page": page_data.page,
                        "size": page_data.size,
                        "pages": page_data.pages,
                    }
                )
            )

    async def detail(self, id: int) -> JSONResponse:
        """获取话题详情"""
        async with get_async_session() as session:
            result = await session.execute(
                select(ContentTopic).where(ContentTopic.id == id)
            )
            topic = result.scalar_one_or_none()

            if not topic:
                return error("话题不存在")

            info = {
                "id": topic.id,
                "platform": topic.platform,
                "platform_question_id": topic.platform_question_id,
                "title": topic.title,
                "description": topic.description,
                "url": topic.url,
                "view_count": topic.view_count,
                "answer_count": topic.answer_count,
                "follower_count": topic.follower_count,
                "category": topic.category,
                "hot_score": topic.hot_score,
                "author_name": topic.author_name,
                "author_url": topic.author_url,
                "status": topic.status,
                "fetched_at": format_datetime(topic.fetched_at) if topic.fetched_at else None,
                "created_at": format_datetime(topic.created_at) if topic.created_at else None,
            }

            return success(info)

    async def use_topic(self, id: int) -> JSONResponse:
        """使用话题（标记为已使用）"""
        async with get_async_session() as session:
            result = await session.execute(
                select(ContentTopic).where(ContentTopic.id == id)
            )
            topic = result.scalar_one_or_none()

            if not topic:
                return error("话题不存在")

            # 更新状态为已使用
            topic.status = 1  # 1=已使用
            topic.updated_at = now()
            await session.commit()

            return success(
                {
                    "id": topic.id,
                    "title": topic.title,
                    "description": topic.description,
                    "url": topic.url,
                    "message": "话题已标记为使用，可以开始写作",
                }
            )

    async def favorite(self, id: int) -> JSONResponse:
        """收藏话题"""
        async with get_async_session() as session:
            result = await session.execute(
                select(ContentTopic).where(ContentTopic.id == id)
            )
            topic = result.scalar_one_or_none()

            if not topic:
                return error("话题不存在")

            # 切换收藏状态
            topic.status = 2 if topic.status != 2 else 0  # 2=已收藏, 0=未使用
            topic.updated_at = now()
            await session.commit()

            action = "收藏" if topic.status == 2 else "取消收藏"
            return success(
                {
                    "id": topic.id,
                    "status": topic.status,
                    "message": f"话题已{action}",
                }
            )

    async def destroy(self, id: int) -> JSONResponse:
        """删除话题"""
        return await self.common_destroy(id=id, model_class=ContentTopic)

    async def destroy_all(self, id_array: list[int]) -> JSONResponse:
        """批量删除话题"""
        return await self.common_destroy_all(
            id_array=id_array, model_class=ContentTopic
        )
```

### 3.4 API 路由

#### 文件：`server/Modules/content/routers/topic_router.py`

```python
"""
Content 话题路由
"""

from fastapi import APIRouter

from Modules.content.services.topic_service import TopicService

router = APIRouter(prefix="/content/topics", tags=["内容管理-话题"])

service = TopicService()


@router.get("/fetch")
async def fetch_topics(
    platform: str,
    platform_account_id: int,
    limit: int = 20,
):
    """抓取平台推荐话题（同步执行，预计耗时 10-30 秒）"""
    return await service.fetch_topics(platform, platform_account_id, limit)


@router.get("")
async def list_topics(data: dict = None):
    """获取话题列表"""
    if data is None:
        data = {}
    return await service.index(data)


@router.get("/{id}")
async def get_topic_detail(id: int):
    """获取话题详情"""
    return await service.detail(id)


@router.post("/{id}/use")
async def use_topic(id: int):
    """使用话题"""
    return await service.use_topic(id)


@router.post("/{id}/favorite")
async def favorite_topic(id: int):
    """收藏/取消收藏话题"""
    return await service.favorite(id)


@router.delete("/{id}")
async def delete_topic(id: int):
    """删除话题"""
    return await service.destroy(id)


@router.delete("/all")
async def delete_topics(id_array: list[int]):
    """批量删除话题"""
    return await service.destroy_all(id_array)
```

---

## 四、前端实现

### 4.1 API 服务

#### 文件：`admin-web/src/services/content/topic/api.ts`

```typescript
import { request } from '@umijs/max';

// 获取话题列表
export async function getList(params: API.TopicRequest) {
  return request<API.Response>('/api/content/topics', {
    method: 'GET',
    params,
  });
}

// 获取话题详情
export async function getDetail(id: number) {
  return request<API.Response>(`/api/content/topics/${id}`, {
    method: 'GET',
  });
}

// 抓取新话题（同步请求，超时时间设置为 60 秒）
export async function fetchTopics(data: {
  platform: string;
  platform_account_id: number;
  limit?: number;
}) {
  return request<API.Response>('/api/content/topics/fetch', {
    method: 'GET',
    params: data,
    timeout: 60000, // 60秒超时
  });
}

// 使用话题
export async function useTopic(id: number) {
  return request<API.Response>(`/api/content/topics/${id}/use`, {
    method: 'POST',
  });
}

// 收藏/取消收藏话题
export async function favoriteTopic(id: number) {
  return request<API.Response>(`/api/content/topics/${id}/favorite`, {
    method: 'POST',
  });
}

// 删除话题
export async function destroy(id: number) {
  return request<API.Response>(`/api/content/topics/${id}`, {
    method: 'DELETE',
  });
}

// 批量删除话题
export async function destroyAll(id_array: number[]) {
  return request<API.Response>('/api/content/topics/all', {
    method: 'DELETE',
    data: { id_array },
    customHeaders: { 'Content-Type': 'application/json' },
  });
}
```

### 4.2 类型定义

#### 文件：`admin-web/src/services/content/topic.d.ts`

```typescript
declare namespace API {
  type TopicStatus = 0 | 1 | 2; // 0=未使用, 1=已使用, 2=已收藏

  interface ContentTopic {
    id: number;
    platform: string;
    platform_question_id: string;
    title: string;
    description?: string;
    url?: string;
    view_count: number;
    answer_count: number;
    follower_count: number;
    category?: string;
    hot_score?: number;
    author_name?: string;
    author_url?: string;
    status: TopicStatus;
    fetched_at: string;
    created_at: string;
  }

  interface TopicRequest extends BaseRequest {
    platform?: string;
    status?: TopicStatus;
    category?: string;
  }

  interface TopicUseRequest {
    topic_id: number;
    article_id?: number;
  }
}
```

### 4.3 话题列表组件

#### 文件：`admin-web/src/pages/content/topic/index.tsx`

```typescript
import { CDel, CDelAll, ProTableWrapper } from '@/components';
import { destroy, destroyAll, fetchTopics, favoriteTopic, getList, useTopic } from '@/services/content/topic/api';
import { getSort, setLsetData } from '@/utils/utils';
import type { ActionType, ProColumns } from '@ant-design/pro-components';
import { Badge, message, Space, Tag, Tooltip } from 'antd';
import { useRef, useState } from 'react';
import { Button } from 'antd';
import { ReloadOutlined, StarFilled, StarOutlined, ThunderboltOutlined } from '@ant-design/icons';
import FetchModal from './components/FetchModal';
import TopicDrawer from './components/TopicDrawer';

const Index: React.FC = () => {
  const actionRef = useRef<ActionType>(null);
  const [loading, setLoading] = useState(true);
  const [selectedRowKeys, setSelectedRowKeys] = useState<React.Key[]>([]);
  const [fetchModalVisible, setFetchModalVisible] = useState(false);
  const [topicDrawerVisible, setTopicDrawerVisible] = useState(false);
  const [selectedTopic, setSelectedTopic] = useState<API.ContentTopic | null>(null);

  const columns: ProColumns<API.ContentTopic>[] = [
    {
      title: '编号',
      dataIndex: 'id',
      hideInSearch: true,
      align: 'center',
      width: 80,
      fixed: true,
    },
    {
      title: '问题标题',
      dataIndex: 'title',
      align: 'center',
      width: 300,
      ellipsis: true,
      copyable: true,
      render: (_, record) => (
        <a href={record.url} target="_blank" rel="noopener noreferrer">
          {record.title}
        </a>
      ),
    },
    {
      title: '平台',
      dataIndex: 'platform',
      valueType: 'select',
      width: 100,
      align: 'center',
      valueEnum: {
        zhihu: { text: '知乎', status: 'Default' },
      },
    },
    {
      title: '分类',
      dataIndex: 'category',
      width: 120,
      align: 'center',
      hideInTable: true,
    },
    {
      title: '分类',
      dataIndex: 'category',
      width: 100,
      align: 'center',
      hideInSearch: true,
      render: (_, record) => record.category || '-',
    },
    {
      title: '状态',
      dataIndex: 'status',
      valueType: 'select',
      width: 100,
      align: 'center',
      valueEnum: {
        0: { text: '未使用', status: 'Default' },
        1: { text: '已使用', status: 'Success' },
        2: { text: '已收藏', status: 'Processing' },
      },
    },
    {
      title: '热度',
      dataIndex: 'hot_score',
      hideInSearch: true,
      width: 100,
      align: 'center',
      sorter: true,
      render: (_, record) => (
        <Space>
          <ThunderboltOutlined twoToneColor="#ff4d4f" />
          {record.hot_score?.toLocaleString() || '-'}
        </Space>
      ),
    },
    {
      title: '浏览量',
      dataIndex: 'view_count',
      hideInSearch: true,
      width: 100,
      align: 'center',
      sorter: true,
      render: (text) => text?.toLocaleString() || '-',
    },
    {
      title: '回答数',
      dataIndex: 'answer_count',
      hideInSearch: true,
      width: 100,
      align: 'center',
      sorter: true,
      render: (text) => text?.toLocaleString() || '-',
    },
    {
      title: '抓取时间',
      dataIndex: 'fetched_at',
      valueType: 'dateTime',
      sorter: true,
      hideInSearch: true,
      width: 180,
      align: 'center',
    },
    {
      title: '操作',
      key: 'option',
      width: 200,
      valueType: 'option',
      align: 'center',
      fixed: 'right',
      render: (_, row) => [
        <Tooltip key="use" title="使用此话题创建文章">
          <Button
            type="primary"
            size="small"
            onClick={() => handleUseTopic(row)}
          >
            使用
          </Button>
        </Tooltip>,
        <Tooltip key="favorite" title={row.status === 2 ? '取消收藏' : '收藏'}>
          <Button
            size="small"
            icon={row.status === 2 ? <StarFilled /> : <StarOutlined />}
            onClick={async () => {
              const res = await favoriteTopic(row.id);
              if (res.code === 200) {
                message.success(res.message);
                actionRef.current?.reload();
              }
            }}
          />
        </Tooltip>,
        <CDel
          key="delete"
          onCancel={async () => {
            const res = await destroy(row.id);
            if (res.code === 200) {
              message.success(res.message);
              actionRef.current?.reload();
            }
          }}
        />,
      ],
    },
  ];

  const handleUseTopic = async (topic: API.ContentTopic) => {
    // 标记为已使用
    const res = await useTopic(topic.id);
    if (res.code === 200) {
      // 跳转到文章编辑页面，并预填充标题
      // 方式1: 使用路由跳转
      // window.location.href = `/content/article/create?title=${encodeURIComponent(topic.title)}`;

      // 方式2: 打开文章编辑抽屉
      setSelectedTopic(topic);
      setTopicDrawerVisible(true);
      message.success('话题已选择，请编辑文章内容');
    }
  };

  const handleFetchSuccess = () => {
    setFetchModalVisible(false);
    actionRef.current?.reload();
  };

  return (
    <>
      <ProTableWrapper
        loading={loading}
        actionRef={actionRef}
        rowKey="id"
        rowSelection={{
          fixed: true,
          selectedRowKeys,
          onChange: (selectedRowKeys) => {
            setSelectedRowKeys(selectedRowKeys);
          },
        }}
        columns={columns}
        request={async (params: API.TopicRequest, sort) => {
          setLoading(true);
          const data = await getSort(params, sort);
          const res = await getList(data);
          setLoading(false);
          return await setLsetData(res);
        }}
        tableAlertOptionRender={({ selectedRowKeys, onCleanSelected }) => (
          <Space size={16}>
            <CDelAll
              key={selectedRowKeys.length}
              count={selectedRowKeys.length}
              onCancel={async () => {
                const res = await destroyAll({ id_array: selectedRowKeys });
                if (res.code === 200) {
                  message.success(res.message);
                  actionRef.current?.reload();
                  onCleanSelected();
                }
              }}
            />
          </Space>
        )}
        headerTitle={
          <Button
            type="primary"
            icon={<ThunderboltOutlined />}
            onClick={() => setFetchModalVisible(true)}
          >
            抓取话题
          </Button>
        }
      />

      <FetchModal
        visible={fetchModalVisible}
        onCancel={() => setFetchModalVisible(false)}
        onConfirm={handleFetchSuccess}
      />

      <TopicDrawer
        visible={topicDrawerVisible}
        topic={selectedTopic}
        onClose={() => {
          setTopicDrawerVisible(false);
          setSelectedTopic(null);
        }}
        onConfirm={() => {
          setTopicDrawerVisible(false);
          setSelectedTopic(null);
          actionRef.current?.reload();
        }}
      />
    </>
  );
};

export default Index;
```

### 4.4 抓取模态框组件

#### 文件：`admin-web/src/pages/content/topic/components/FetchModal.tsx`

```typescript
import { getList as getAccountList } from '@/services/content/platformAccount/api';
import { fetchTopics } from '@/services/content/topic/api';
import { ModalForm, ProFormSelect } from '@ant-design/pro-components';
import { message } from 'antd';
import { useState, useEffect } from 'react';

interface PropsType {
  visible: boolean;
  onCancel: () => void;
  onConfirm: () => void;
}

const FetchModal: React.FC<PropsType> = (props) => {
  const [accountOptions, setAccountOptions] = useState<{ label: string; value: number }[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (props.visible) {
      fetchAccountOptions();
    }
  }, [props.visible]);

  const fetchAccountOptions = async () => {
    const res = await getAccountList({ page: 1, limit: 100, platform: 'zhihu', status: 1 });
    if (res.code === 200 && res.data?.items) {
      const options = res.data.items.map((item: API.ContentPlatformAccount) => ({
        label: `${item.account_name} (${item.status === 1 ? '有效' : '失效'})`,
        value: item.id,
      }));
      setAccountOptions(options);
    }
  };

  return (
    <ModalForm
      title="抓取知乎推荐话题"
      open={props.visible}
      onOpenChange={props.onCancel}
      onFinish={async (values) => {
        setLoading(true);
        try {
          const res = await fetchTopics({
            platform: 'zhihu',
            platform_account_id: values.platform_account_id,
            limit: values.limit || 20,
          });
          setLoading(false);
          if (res.code === 200) {
            message.success(res.message);
            props.onConfirm();
            return true;
          }
          return false;
        } catch (error) {
          setLoading(false);
          message.error('抓取失败，请稍后重试');
          return false;
        }
      }}
      submitter={{
        searchConfig: {
          submitText: '开始抓取',
          resetText: '取消',
        },
        submitButtonProps: {
          loading,
          disabled: loading,
        },
      }}
    >
      <ProFormSelect
        name="platform_account_id"
        label="知乎账号"
        placeholder="请选择要使用的知乎账号"
        options={accountOptions}
        rules={[{ required: true, message: '请选择知乎账号' }]}
        fieldProps={{
          showSearch: true,
          filterOption: (input, option) =>
            (option?.label ?? '').toLowerCase().includes(input.toLowerCase()),
        }}
      />
      <ProFormSelect
        name="limit"
        label="抓取数量"
        placeholder="请选择抓取数量"
        options={[
          { label: '10个', value: 10 },
          { label: '20个', value: 20 },
          { label: '50个', value: 50 },
        ]}
        initialValue={20}
        rules={[{ required: true, message: '请选择抓取数量' }]}
      />
    </ModalForm>
  );
};

export default FetchModal;
```

### 4.5 话题写作抽屉组件

#### 文件：`admin-web/src/pages/content/topic/components/TopicDrawer.tsx`

```typescript
import ProFormTinyMCE from '@/components/common/ProFormTinyMCE';
import { add } from '@/services/content/article/api';
import { DrawerForm, ProFormText, ProFormTextArea } from '@ant-design/pro-components';
import { message } from 'antd';
import React from 'react';

interface PropsType {
  visible: boolean;
  topic: API.ContentTopic | null;
  onClose: () => void;
  onConfirm: () => void;
}

const TopicDrawer: React.FC<PropsType> = (props) => {
  return (
    <DrawerForm
      title="基于话题创建文章"
      open={props.visible}
      onOpenChange={props.onClose}
      onFinish={async (values) => {
        const res = await add({
          ...values,
          tag_ids: values.tag_ids?.join(',') || '',
        });
        if (res.code === 200) {
          message.success(res.message);
          props.onConfirm();
          return true;
        }
        return false;
      }}
      width={800}
      drawerProps={{
        destroyOnClose: true,
      }}
      initialValues={{
        title: props.topic?.title || '',
        summary: props.topic?.description || '',
        content: `# ${props.topic?.title}\n\n${props.topic?.description || ''}\n\n> 参考链接：${props.topic?.url || ''}`,
        status: 0,
      }}
    >
      <ProFormText
        name="title"
        label="文章标题"
        placeholder="请输入文章标题"
        rules={[{ required: true, message: '请输入文章标题' }]}
      />

      <ProFormTextArea
        name="summary"
        label="文章摘要"
        placeholder="请输入文章摘要"
        fieldProps={{
          rows: 3,
          showCount: true,
          maxLength: 500,
        }}
      />

      <ProFormTinyMCE
        name="content"
        label="文章内容"
        placeholder="请输入文章内容..."
        rules={[{ required: true, message: '请输入文章内容' }]}
        required
        height={400}
      />
    </DrawerForm>
  );
};

export default TopicDrawer;
```

---

## 五、API 接口文档

### 5.1 抓取话题

```http
GET /api/content/topics/fetch?platform=zhihu&platform_account_id=1&limit=20
```

**请求参数：**

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| platform | string | 是 | 平台标识（zhihu） |
| platform_account_id | int | 是 | 平台账号ID |
| limit | int | 否 | 抓取数量，默认20 |

**响应示例：**

```json
{
  "code": 200,
  "message": "成功抓取 20 个话题（新增 15 个，更新 5 个）",
  "data": {
    "total": 20,
    "created": 15,
    "updated": 5,
    "skipped": 0,
    "platform": "zhihu"
  }
}
```

**注意事项：**
- 此接口为同步执行，预计耗时 10-30 秒
- 前端需设置超时时间为 60 秒
- 抓取期间请关闭模态框或显示 Loading 状态

### 5.2 获取话题列表

```http
GET /api/content/topics?page=1&limit=20&status=0
```

**请求参数：**

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| page | int | 否 | 页码，默认1 |
| limit | int | 否 | 每页数量，默认20 |
| platform | string | 否 | 平台筛选 |
| status | int | 否 | 状态筛选：0=未使用, 1=已使用, 2=已收藏 |
| category | string | 否 | 分类筛选 |
| sort | string | 否 | 排序字段 |

**响应示例：**

```json
{
  "code": 200,
  "data": {
    "items": [
      {
        "id": 1,
        "platform": "zhihu",
        "platform_question_id": "12345678",
        "title": "如何学习Python编程？",
        "description": "我是编程初学者，想学习Python...",
        "url": "https://www.zhihu.com/question/12345678",
        "view_count": 12500,
        "answer_count": 156,
        "follower_count": 89,
        "category": "编程学习",
        "hot_score": 14060,
        "author_name": "张三",
        "status": 0,
        "fetched_at": "2025-01-15 10:30:00",
        "created_at": "2025-01-15 10:30:00"
      }
    ],
    "total": 100,
    "page": 1,
    "size": 20,
    "pages": 5
  }
}
```

### 5.3 使用话题

```http
POST /api/content/topics/{id}/use
```

**响应示例：**

```json
{
  "code": 200,
  "message": "话题已标记为使用，可以开始写作",
  "data": {
    "id": 1,
    "title": "如何学习Python编程？",
    "description": "我是编程初学者，想学习Python...",
    "url": "https://www.zhihu.com/question/12345678"
  }
}
```

### 5.4 收藏话题

```http
POST /api/content/topics/{id}/favorite
```

**响应示例：**

```json
{
  "code": 200,
  "message": "话题已收藏",
  "data": {
    "id": 1,
    "status": 2
  }
}
```

### 5.5 删除话题

```http
DELETE /api/content/topics/{id}
```

---

## 六、使用流程

### 6.1 前提条件

1. 已配置知乎平台账号（在"平台账号管理"中添加）
2. 知乎账号 Cookie 有效且已验证
3. 已完成数据库迁移（创建 `content_topics` 表）

### 6.2 操作步骤

```
┌─────────────────────────────────────────────────────────────┐
│                    1. 进入话题管理页面                        │
│                 导航：内容管理 > 话题管理                     │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    2. 点击"抓取话题"按钮                      │
│              页面顶部的主按钮，打开抓取模态框                 │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    3. 选择抓取参数                            │
│              - 选择知乎账号（状态为有效的账号）               │
│              - 选择抓取数量（10/20/50个）                     │
│              - 点击"开始抓取"按钮                            │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    4. 等待抓取完成                            │
│              按钮显示 Loading 状态，预计 10-30 秒             │
│              - 正在访问知乎...                               │
│              - 正在解析话题...                               │
│              - 正在存储数据...                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    5. 查看抓取结果                            │
│              系统自动抓取并存储话题到数据库                   │
│              显示成功提示：新增 X 个，更新 Y 个               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    6. 浏览话题列表                            │
│         按热度/时间排序，支持按分类、状态筛选                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    7. 选择感兴趣的话题                         │
│              可收藏、使用话题创建文章                          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    8. 使用话题创建文章                        │
│        点击"使用"按钮，系统自动填充标题和描述                  │
│              用户可编辑内容后保存为草稿或发布                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 七、扩展计划

### 7.1 短期扩展（1-2周）

| 功能 | 描述 | 优先级 |
|------|------|--------|
| **多平台支持** | 扩展到简书、掘金、CSDN 等平台 | 高 |
| **AI 辅助写作** | 结合话题自动生成文章大纲和内容 | 中 |
| **话题统计** | 话题使用情况、热门话题分析 | 中 |
| **进度提示优化** | 显示抓取进度和步骤详情 | 中 |

### 7.2 中期扩展（1个月）

| 功能 | 描述 |
|------|------|
| **话题推荐算法** | 基于用户历史选择智能推荐话题 |
| **话题趋势分析** | 展示话题热度变化曲线 |
| **评论同步** | 抓取话题下优质回答作为参考 |
| **批量操作** | 批量使用多个话题创建文章系列 |

### 7.3 长期扩展（3个月+）

| 功能 | 描述 |
|------|------|
| **定时自动抓取** | 使用 Celery 定时任务自动抓取最新话题 |
| **全网热点聚合** | 整合微博、知乎、百度等平台热点 |
| **话题追踪** | 监控话题的持续热度和变化 |
| **SEO 优化建议** | 基于话题提供 SEO 关键词建议 |
| **内容质量评分** | AI 评估文章质量并给出改进建议 |

---

## 附录

### A. 配置文件

需要在 `server/Modules/common/libs/config/content_config.py` 中添加：

```python
# 话题抓取配置
topic_fetch_enabled: bool = True  # 是否启用话题抓取功能
topic_fetch_timeout: int = 60  # 抓取超时时间（秒）
topic_max_cache_days: int = 7  # 话题缓存天数
```

### B. 数据库迁移

使用 Alembic 创建迁移：

```bash
# 生成迁移文件
alembic revision --autogenerate -m "add content_topics table"

# 执行迁移
alembic upgrade head
```

### C. 超时与并发处理

#### C.1 前端超时设置

```typescript
// api.ts 中设置 60 秒超时
export async function fetchTopics(data: {...}) {
  return request<API.Response>('/api/content/topics/fetch', {
    method: 'GET',
    params: data,
    timeout: 60000, // 60秒超时
  });
}
```

#### C.2 后端超时处理

```python
# topic_router.py
@router.get("/fetch")
async def fetch_topics(...):
    # 使用 asyncio.wait_timeout 添加超时控制
    try:
        result = await asyncio.wait_for(
            service.fetch_topics(...),
            timeout=60.0  # 60秒超时
        )
    except asyncio.TimeoutError:
        return error("抓取超时，请稍后重试")
```

#### C.3 并发控制建议

**方案A：简单的全局锁（推荐用于初期）**

```python
import asyncio

# 全局抓取锁
_fetch_lock = asyncio.Lock()

async def fetch_topics(self, ...):
    async with _fetch_lock:
        # 执行抓取逻辑
        ...
```

**方案B：队列机制（用于多人协作）**

```python
from collections import deque
from fastapi import BackgroundTasks

# 全局任务队列
_fetch_queue = deque()
_fetching = False

async def fetch_topics(self, background_tasks: BackgroundTasks, ...):
    global _fetching, _fetch_queue

    if _fetching:
        # 正在抓取，加入队列
        background_tasks.add_task(self._fetch_in_background, ...)
        return success({"message": "已加入抓取队列"})

    # 直接执行抓取
    ...
```

### D. 常见错误处理

| 错误 | 原因 | 解决方案 |
|------|------|----------|
| "平台账号不存在或已失效" | 账号被删除或状态为失效 | 检查账号状态，重新验证 |
| "Cookie 格式错误" | Cookie 存储格式不正确 | 重新添加账号 Cookie |
| "知乎账号未登录" | Cookie 已过期 | 重新获取并更新 Cookie |
| "抓取超时" | 网络慢或页面加载慢 | 增加超时时间或重试 |
| "未找到问题列表" | 页面结构变化 | 更新选择器或使用 API 备用方案 |

### E. 前端 Loading 优化建议

```typescript
// 显示详细的抓取进度
const [fetchStep, setFetchStep] = useState('');
const [fetchProgress, setFetchProgress] = useState(0);

// 在抓取过程中更新状态
const steps = [
  { text: '正在启动浏览器...', progress: 10 },
  { text: '正在访问知乎...', progress: 30 },
  { text: '正在解析话题...', progress: 60 },
  { text: '正在存储数据...', progress: 90 },
  { text: '抓取完成！', progress: 100 },
];

// 显示在模态框中
<Modal>
  <Spin spinning={loading}>
    <Progress percent={fetchProgress} />
    <p>{fetchStep}</p>
  </Spin>
</Modal>
```

---

**文档版本：** v1.1
**最后更新：** 2025-01-15
**维护者：** Py-Small-Admin Team
**更新内容：** 移除 Celery 定时任务，采用手动按钮触发方式
